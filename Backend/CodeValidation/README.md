- "check_ea_blackbox_data.js" checks if all the components extracted from an EA Blackbox are used through all the C files given as input. Each component must be used at least once through all files (so if it is used once in a file and it is missing from the rest of the files, it is fine).

- "check_flow_diagram_implementation.js" checks whether the code logic defined in an EA diagram is implemented in a single C file. Additional details:
- we use a mapping file which is a translation of the flow logic defined in the EA diagram, to a syntax that can be used to recursively check if the logic is implemented in the code.
- the mapping file can be generated through a script, however the customer has not paid to have this script in the PoC. In order to have this functionality for Production, the approach is the following:
1. In the XML given as input (the XML describes the flow chart diagram), apply regex to detect the transitions (the code logic is similar to the one implemented in "extract-blackbox-data.js", but we have to search for "UML:Transition" instead of "UML:Package")

2. For each transition match, extract the values for the fields called: "ea_sourceName", "ea_targetName", "ea_sourceID", "ea_targetID" from the "UML:TaggedValue" children elements, and the "name" attribute from the "UML:Transition" itself. The value of "ea_sourceName" is used to generate "Arg", "Op", "Type" for "map.json". When we generate "ChildrenTrue" and "ChildrenFalse", we need to take into account the values of "name", "ea_sourceID" and "ea_targetID". The fields "ea_sourceID" and "ea_targetID" are used to ensure that we don't include the wrong children in case there are multiple elements with the same "ea_sourceName", while the "name" field of "UML:TaggedValue" tells us in which direction to go ("ChildrenTrue" or "ChildrenFalse").

3. After the data mentioned in the step above is extracted, we basically have a graph. We traverse the graph starting from the "ea_sourceID" corresponding to the root element, updating the "map" object with each traversal step. Finally, we export the "map" object in a file called "map.json".
- "check_flow_diagram_implementation.js" also supports "else" detection. This is why in the function "makeBracketPairs()", we precompute for each `{` character, the position of the corresponding closing `}`. When we detect that a condition contains the values in "Arg", but the operator does not match "Op" or the corresponding reverse operators, we detect whether there is an else immediately after the `}` of the initial 'if'.
- We check for reverse operators as well. If the condition in the diagram is 'a' < 'b', but in the code it is written as 'b' > 'a', it is ok.
- The schema provided by "map.json" is recursively traversed. 'Left' & 'right' parameters tell us what is the portion of the code where we are allowed to check for the next condition. That is because a requirement from the customer was to check if the conditions are implemented as nested "ifs". For example, let's assume that in the flow diagram we have 'a' < 'b' -> 'c' < 'd'. Then, in the code, we need to check `if (a < b) { if (c < d) {...}}`. The `if (c < d)` has to be inside the `if (a < b)`.
- The mapping schema can be extended to support any operation, as long as the customer pays for it. The customer showed interest in the assignment operation as well.